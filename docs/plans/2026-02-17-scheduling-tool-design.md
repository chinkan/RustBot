# Scheduling Tool Design

**Date:** 2026-02-17
**Status:** Approved
**Branch:** `claude/rustbot-scheduling-tool-nLhrR`

## Overview

Add a scheduling system to RustBot that allows users to register one-shot and recurring tasks via natural language. When a scheduled task fires, it triggers the full agentic loop as if the user sent a message — the LLM has access to all tools and auto-selects what's needed for the job.

## Goals

- Users can say "remind me happy birthday at 12:00 on March 5th" and the bot registers, persists, and fires the task automatically
- Scheduled prompts trigger a full agentic loop (all tools available — file I/O, commands, memory, MCP, scheduling tools themselves)
- Tasks survive bot restarts (persisted in SQLite)
- Both one-shot and recurring schedules supported via natural language → LLM converts to ISO 8601 or cron expression
- Users can list and cancel their own tasks

## Approach: LLM-First Tool

The LLM does the natural language → structured conversion when invoking the scheduling tools. No additional NLP crates needed. The tool definitions include explicit format guidance so the model reliably outputs ISO datetimes and cron expressions.

## Database Schema

Added to existing `rustbot.db` (SQLite):

```sql
CREATE TABLE IF NOT EXISTS scheduled_tasks (
    id               TEXT PRIMARY KEY,
    scheduler_job_id TEXT,
    user_id          TEXT NOT NULL,
    chat_id          TEXT NOT NULL,
    platform         TEXT NOT NULL,
    trigger_type     TEXT NOT NULL,   -- "one_shot" | "recurring"
    trigger_value    TEXT NOT NULL,   -- ISO 8601 datetime OR 6-field cron expression
    prompt           TEXT NOT NULL,   -- Injected into agentic loop at trigger time
    description      TEXT NOT NULL,   -- Human-readable label
    status           TEXT NOT NULL DEFAULT 'active',  -- "active" | "completed" | "cancelled" | "failed"
    created_at       TEXT NOT NULL,
    next_run_at      TEXT             -- Next fire time (computed, for display/ordering)
);
```

**Notes:**
- `id` is a UUID generated by RustBot before scheduler registration
- `scheduler_job_id` is the UUID returned by `tokio-cron-scheduler` (re-created on restart)
- One-shot tasks are marked `completed` after firing; recurring tasks stay `active`
- `next_run_at` updated after each recurring fire

## Architecture

### Files Changed

```
src/
├── scheduler/
│   ├── mod.rs          # EXTENDED: add_one_shot_job(), cancel_job(), return Uuid
│   ├── tasks.rs        # EXTENDED: restore_scheduled_tasks() on startup
│   └── reminders.rs    # NEW: ScheduledTaskStore (SQLite CRUD)
├── tools.rs            # EXTENDED: 3 new scheduling tools
├── agent.rs            # EXTENDED: accept Arc<Bot> for trigger dispatch
└── main.rs             # EXTENDED: wire ScheduledTaskStore, call restore on startup
```

### New Tools (exposed to LLM)

#### `schedule_task`
```json
{
  "name": "schedule_task",
  "description": "Schedule a task to run at a future time. The prompt will be sent to the AI agent at the scheduled time, triggering a full agentic loop. For one_shot: trigger_value is ISO 8601 datetime (e.g. '2026-03-05T12:00:00'). For recurring: trigger_value is a 6-field cron expression (sec min hour day month weekday, e.g. '0 0 9 * * MON' for every Monday at 9am).",
  "parameters": {
    "trigger_type":  { "type": "string", "enum": ["one_shot", "recurring"] },
    "trigger_value": { "type": "string" },
    "prompt":        { "type": "string" },
    "description":   { "type": "string" }
  },
  "required": ["trigger_type", "trigger_value", "prompt", "description"]
}
```

#### `list_scheduled_tasks`
```json
{
  "name": "list_scheduled_tasks",
  "description": "List all active scheduled tasks for the current user.",
  "parameters": {}
}
```

#### `cancel_scheduled_task`
```json
{
  "name": "cancel_scheduled_task",
  "description": "Cancel an active scheduled task by its ID.",
  "parameters": {
    "task_id": { "type": "string" }
  },
  "required": ["task_id"]
}
```

### Trigger Dispatch Flow

```
tokio-cron-scheduler fires job
  → job closure holds: Arc<Agent>, Arc<Bot>, user_id, chat_id, task_id, prompt, Arc<ScheduledTaskStore>
  → mark one_shot as completed in DB (before loop, prevents duplicate on crash)
  → agent.process_message(IncomingMessage { user_id, chat_id, platform: "telegram", text: prompt })
  → full agentic loop runs with all tools available
  → response sent via Bot::send_message(chat_id, response)
  → recurring: update next_run_at in DB
```

### Startup Restore Flow

```
main.rs initializes ScheduledTaskStore
  → load all status='active' tasks from DB
  → for each task:
      one_shot, next_run_at in past ≤1h  → fire immediately (missed)
      one_shot, next_run_at in past >1h  → mark completed, store note in memory
      one_shot, next_run_at in future    → register one-shot with remaining duration
      recurring                          → re-register cron job
  → update scheduler_job_id in DB for all re-registered tasks
```

### Shared State for Job Closures

```rust
// Captured by each scheduled job closure:
Arc<Agent>               // for process_message()
Arc<Bot>                 // teloxide Bot for send_message()
Arc<ScheduledTaskStore>  // for marking complete / updating next_run_at
String                   // user_id (captured at creation)
String                   // chat_id (captured at creation)
String                   // task_id (for DB update)
String                   // prompt (injected into agentic loop)
```

## Error Handling

| Scenario | Behavior |
|----------|----------|
| Invalid ISO datetime or cron expression | Tool returns error string to LLM; LLM asks user to clarify |
| `trigger_value` is in the past (one_shot) | Tool returns error: "That time has already passed" |
| `cancel_scheduled_task` unknown ID | Returns "Task not found or already completed" |
| LLM/OpenRouter call fails at trigger time | Log error, retry once after 5s, mark task `failed` |
| Telegram send fails at trigger time | Log error, task still marked completed (avoid duplicate fires) |
| One-shot missed by ≤1 hour on restart | Fire immediately |
| One-shot missed by >1 hour on restart | Mark completed, store note in memory knowledge store |
| Recurring missed fires on restart | Re-register cron; scheduler picks next occurrence naturally |

## User Isolation

- `list_scheduled_tasks` and `cancel_scheduled_task` are scoped to the requesting `user_id`
- Scheduler job closures capture `user_id` at creation — no runtime lookup needed

## Example Interaction

```
User:  "Remind me happy birthday at 12:00 on March 5th"

LLM calls: schedule_task(
  trigger_type  = "one_shot",
  trigger_value = "2026-03-05T12:00:00",
  prompt        = "Wish the user a happy birthday with a warm message!",
  description   = "Birthday reminder"
)

Bot replies: "Done! I'll wish you a happy birthday on March 5th at 12:00."

--- March 5th, 12:00:00 ---

Scheduler fires → agent.process_message("Wish the user a happy birthday with a warm message!")
LLM generates:  "Happy Birthday! Hope you have a wonderful day!"
Bot sends to user.
DB marks task as completed.
```

## Non-Goals (out of scope)

- Timezone support (all times treated as local server time for now)
- Task editing (cancel + recreate)
- Cross-user task visibility
- Rate limiting on number of scheduled tasks per user
